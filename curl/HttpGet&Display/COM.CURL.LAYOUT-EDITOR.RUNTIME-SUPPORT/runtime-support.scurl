||| Copyright (C) 1998-2022, SCSK Corporation. All Rights Reserved.

{curl 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 package}

{package COM.CURL.LAYOUT-EDITOR.RUNTIME-SUPPORT,
    resource-directory = "../curl-resources",
    translations-file = "translations.xml",
    default-locale = "en",
    version = "3.0"
}

||| WARNING!
||| This file is generated and rewritten by the Visual Layout Editor
||| and should not be modified.  If you change the file's contents,
||| your changes may be lost.

||| This package needs to be imported into any applet or package that 
||| includes a file generated by Curl's Visual Layout Editor.
||| 
||| It exports the define-layout-class macro that is generated
||| by the VLE, as well as some new classes that are not part of the
||| standard GUI toolkit, but are used by the VLE.

||| -- Defined in this file --
||| 
|||  Macros:
|||   define-layout-class

|||  Classes:
|||   LayoutEditorContainer
|||   RadioCanvas
|||   ImageFrame

|||  Procs:
|||   has-prefix-name?
|||   parse-layout-class
|||   parse-layout-element
|||   UserDefinedGraphic


{import * from CURL.GUI.STANDARD}

{import * from CURL.LANGUAGE.SOURCE}
{import * from CURL.LANGUAGE.COMPONENT}

{api-version-switch
 case "4+" do
    || Export the SHAPES and charts APIs for VLE users.
    {import public * from CURL.GUI.SHAPES}
    {import public * from CURL.GUI.CHARTS}
}

|| Purpose:
|| Helper procedure for looking at the prefix.
{define-proc {has-prefix-name? p:Prefix, prefix:String}:
    (match:bool, body:CurlSource, index:ParseIndex)
    let body:CurlSource = p.contents
    let (head:#Parsed, pi:ParseIndex) = {body.parse-head BOS}
    {if head isa Identifier and 
        (head asa Identifier).name == prefix
     then
        {return true, body, pi}
     else
        {return false, body, pi}
    }
}


|| Purpose:
|| Throw a SyntaxError at the position of the given source code.
{define-proc {throw-syntax-error message:String, code:CurlSource}:void
    let (line:int, column:int) =
        {code.location-to-line-column code.start-location}
    {throw {SyntaxError message, code.url, line, column}}
}


|| Purpose:
|| Provide information about a slot defined in a compound object.
{define-class public final VleSlotContentsInfo
  field public constant slot-name:String
  field public constant run-time-type:String

  {constructor public {default
                          slot-name:String,
                          run-time-type:String
                      }
    set self.slot-name = slot-name
    set self.run-time-type = run-time-type
  }
}


|| Purpose:
|| Main routine for parsing layout-class macro
{define-proc {parse-layout-class
                 code:CurlSource, index:ParseIndex,
                 format-version:int = -1,
                 compound-object?:bool = false
             }:CurlSource
    let (expr:#Parsed, ni:ParseIndex) = {code.parse-expression index}
    let last:CurlSource = {uninitialized-value-for-type CurlSource}
    let attributes:{Array-of CurlSource} = {new {Array-of CurlSource}}
    let constructor-attribute:CurlSource = {EmptySource}
    let inherits:CurlSource = {EmptySource}
    {while not (expr isa SingleBinding) do
        set last = {non-null expr}
        {attributes.append last}
        set (expr, ni) = {code.parse-expression ni}
        {if last isa Prefix and 
            {has-prefix-name? last asa Prefix, "inherits"} ||""
         then
            set inherits = last
            {break}
        }
        {if-non-null attr = {last.identifier} then
            {if attr.name == "public" or attr.name == "package" then ||""
                set constructor-attribute = last
            }
        }
    }

    let found-format-version:int = -1
    || Format version 1 didn't include an explicit format-version binding:
    {if format-version == 1 then set found-format-version = 1}

    let run-time-class:#String 
    let design-time-class:#String 
    let arguments:{Array-of CurlSource} = {new {Array-of CurlSource}}
    let other-members:{Array-of CurlSource} = {new {Array-of CurlSource}}
    let fields:{Array-of CurlSource} = {new {Array-of CurlSource}}
    let nonvisual-inits:{Array-of CurlSource} = {new {Array-of CurlSource}}
    let inits:{Array-of CurlSource} = {new {Array-of CurlSource}}
    let slot-names:{Array-of VleSlotContentsInfo} =
        {new {Array-of VleSlotContentsInfo}}

    let in-comma-list?:bool = true
    || in-comma-list? will be set to false when an expression not
    ||   followed by a comma is first encountered.

    {while true do
        {if ni == EOS then {break}}

        let followed-by-comma?:bool = false
        {if in-comma-list? then
            let (cexpr:#Parsed, newi:ParseIndex) =
                {code.parse-token ni}   || look for comma
            {type-switch cexpr
             case op:Operator do
                set followed-by-comma? = (op.kind == OperatorKind.Comma)
            }
            {if followed-by-comma? then
                || Eat comma if present.
                set ni = newi
             elseif format-version == 1 and newi == EOS then
                || Else if we got to the end of the body, then process
                ||   the last expr as though still in the comma list.
             else
                || Else stop looking for commas in this body.
                set in-comma-list? = false
            }
        }
        let can-append-to-args?:bool = in-comma-list?

        let e:CurlSource = {non-null expr}
        set (expr, ni) = {parse-class-member-or-single-binding code, ni}
        {type-switch e
         case sb:SingleBinding do
            {if in-comma-list? then
                let name:String = {sb.name.identifier}.name
                {if name == "design-time-class" then ||""
                    set design-time-class = {sb.value.literal} asa String
                 elseif name == "run-time-class" then ||""
                    set run-time-class = {sb.value.literal} asa String
                 elseif format-version > 1 and name == "format-version" then ||""
                    {if found-format-version != -1 then
                        || The format-version option should not appear more than once:
                        {throw-syntax-error
                            {host-localize "Duplicated format-version parameter"},
                            sb
                        }
                    }
                    set found-format-version = {sb.value.literal} asa int
                    {if found-format-version != format-version then
                        || The format-version must have the right value
                        ||   when it appears:
                        {throw-syntax-error
                            {host-localize "Invalid format-version parameter"},
                            sb
                        }
                    }
                 else
                    {if arguments.size > 0 then
                        {arguments.append {expand-template ,}}
                    }
                    {arguments.append sb}
                }
                {continue}
            }

         case pre:Prefix do
            let match?:bool
            let body:CurlSource = {uninitialized-value-for-type CurlSource}
            let pi:ParseIndex

            set (match?, body, pi) =
                {has-prefix-name? pre, "layout-element"} ||""
            {if match? then
                {parse-layout-element
                    body, pi, fields, nonvisual-inits, inits, slot-names, "",
                    false, true, false, format-version
                }
                {continue}
            }

            set (match?, body, pi) = 
                {has-prefix-name? pre, "layout-container"} ||""
            {if match? then
                {parse-layout-element
                    body, pi, fields, nonvisual-inits, inits, slot-names, "",
                    true, true, false, format-version
                }
                {continue}
            }

            set (match?, body, pi) = 
                {has-prefix-name? pre, "nonvisual-element"} ||""
            {if match? and format-version > 1 then
                {parse-layout-element
                    body, pi, fields, nonvisual-inits, inits, slot-names, "",
                    false, false, false, format-version
                }
                {continue}
            }

            set (match?, body, pi) = 
                {has-prefix-name? pre, "argument-container"} ||""
            {if match? then
                set e =
                    {non-null
                        {parse-layout-element
                            body, pi, fields, nonvisual-inits, inits, slot-names, "",
                            true, true, true, format-version
                        }
                    }
                set can-append-to-args? = true
            }
        }

        {if can-append-to-args? then
            || Not any of the above recognized cases, must be a positional arg:
            {if arguments.size > 0 then
                {arguments.append {expand-template ,}}
            }
            {arguments.append e}
            {continue}
        }

        {other-members.append e}
    }
    {if found-format-version != format-version then
        || The format-version must appear at least once, and must
        ||   have the right value:
        {throw-syntax-error
            {host-localize "Missing format-version parameter"},
            code
        }
    }

    let container-type:CurlSource =
        {CurlSource.from-string {non-null design-time-class}}
    let creation-operator:CurlSource =
        {CurlSource.from-string {non-null run-time-class}}

    let generated-members:CurlSource =
        {if format-version == 1 then
            {expand-template
                source-info = code,
                {?={Identifier "constructor"} ?constructor-attribute {default}
                    let container:?container-type = {?creation-operator ?arguments}
                    {construct-super container}
                    let obj:Graphic = {uninitialized-value-for-type Graphic}
                    ?inits
                }
            }
         else
            let ic-body:CurlSource =
                {expand-template
                    source-info = code,
                    ?nonvisual-inits
                    let container:?container-type = {?creation-operator ?arguments}
                    set ?={Identifier "self"}.container = container
                    let obj:Object = {uninitialized-value-for-type Object}
                    ?inits
                }
            let ic-method:CurlSource =
                {if compound-object? then
                    {expand-template
                        source-info = code,
                        {?={Identifier "method"} private
                                {initialize-components
                                    make-slot-proc:#{proc-type
                                                        {String, String,
                                                         Arguments,
                                                         {proc-type {Visual}:void}
                                                        }:(top-visual:#Visual,
                                                           add-to-visual:Visual
                                                          )
                                                    } = null
                                }:void
                            ?ic-body
                        }

                        {constructor public
                                {instantiate-object-for-vle
                                    make-slot-proc:{proc-type
                                                       {String, String,
                                                        Arguments,
                                                        {proc-type {Visual}:void}
                                                       }:(top-visual:#Visual,
                                                          add-to-visual:Visual
                                                         )
                                                   },
                                    arguments:#Arguments = null
                                }
                            {if-non-null arguments then
                                {construct-super {splice arguments}}
                             else
                                {construct-super}
                            }
                            {self.initialize-components
                                make-slot-proc = make-slot-proc
                            }
                            {self.add-internal self.container}
                        }
                    }
                 else
                    {expand-template
                        source-info = code,
                        {?={Identifier "method"} private
                                {initialize-components
                                }:void
                            ?ic-body
                        }
                    }
                }
            let standard-members:CurlSource =
                {expand-template
                    source-info = code,
                    field public container:?container-type =
                        {uninitialized-value-for-type ?container-type}

                    ?ic-method
                }
            {if compound-object? then
                let slot-name-to-run-time-type-cases:{Array-of CurlSource} =
                    {new {Array-of CurlSource}}
                {for sinfo in slot-names do
                    let sname:String = sinfo.slot-name
                    {slot-name-to-run-time-type-cases.append
                        {expand-template
                            source-info = code,
                            case ?{Literal sinfo.slot-name} do
                               ?{Literal sinfo.run-time-type}
                        }
                    }
                }

                {expand-template
                    source-info = code,
                    field private constant
                            default-slot-contents-hash:{HashTable-of
                                                           String,
                                                           {Array-of Visual}
                                                       } =
                        {new {HashTable-of String, {Array-of Visual}}}

                    field private constant
                            vle-slot-containers-hash:{HashTable-of String, Visual} =
                        {new {HashTable-of String, Visual}}

                    {define-proc public {vle-slot-name-to-run-time-type
                                            slot-name:String
                                        }:#String
                        {return
                            {switch slot-name
                                ?slot-name-to-run-time-type-cases
                             else
                                null
                            }
                        }
                    }

                    ?standard-members

                    {?={Identifier "method"} private {vle-remember-default-slot-contents
                                                         slot-name:String,
                                                         g:#Visual
                                                     }:#Visual
                        {if-non-null g then
                            let hashtab:{HashTable-of String, {Array-of Visual}} =
                                ?={Identifier "self"}.default-slot-contents-hash
                            let (a:{Array-of Visual}, found?:bool) =
                                {hashtab.get-if-exists slot-name}
                            {if not found? then
                                set a = {new {Array-of Visual}}
                                set hashtab[slot-name] = a
                            }
                            {a.append g}
                        }
                        {return g}
                    }

                    {?={Identifier "method"} public open {get-vle-slot-container
                                                             slot-name:String
                                                         }:Visual
                        ?{if slot-names.size == 0 then
                             {expand-template
                                 source-info = code,
                                 {error
                                     {api-version-switch
                                      case "4+" do
                                         {hlmessage
                                             This object does not have any slots
                                             for child objects.
                                         }
                                      else
                                         {message
                                             This object does not have any slots
                                             for child objects.
                                         }
                                     }
                                 }
                             }
                          else
                             {expand-template
                                 let slot-container:Visual =
                                     ?={Identifier "self"}.vle-slot-containers-hash[slot-name]
                                 {return slot-container}
                             }
                         }
                    }

                    {?={Identifier "let"} public constant has-vle-slots?:bool =
                        ?{if slot-names.size == 0 then
                             {expand-template false}
                          else
                             {expand-template true}
                         }
                    }

                    {?={Identifier "method"} private {add-to-slot g:any, ...}:#Visual
                        let add-options:Arguments = {Arguments}
                        let slot-name:String = ""
                        {for (v, k) in ... do
                            {if slot-name == "" and k == "slot" then ||""
                                set slot-name = v asa String
                             else
                                {add-options.append v, keyword = k}
                            }
                        }
                        let hashtab:{HashTable-of String, {Array-of Visual}} =
                            ?={Identifier "self"}.default-slot-contents-hash
                        let (contents:{Array-of Visual}, found?:bool) =
                            {hashtab.get-if-exists slot-name}
                        {if found? then
                            {for c in contents do
                                {type-switch c
                                 case cg:Graphic do
                                    {cg.detach}
                                 else
                                    || It's an error if c isn't a Graphic:
                                    {api-version-switch
                                     case "4+" do
                                        {error
                                            {hlmessage
                                                Can't detach {value c} from
                                                slot '{value slot-name}'.
                                            }
                                        }
                                     else
                                        {assert c isa Graphic}
                                    }
                                }
                            }
                            {hashtab.remove slot-name}
                        }
                        let slot-container:Visual =
                            {?={Identifier "self"}.get-vle-slot-container
                                slot-name
                            }
                        {return {slot-container.add g, {splice add-options}}}
                    }
                }
             else
                {if slot-names.size != 0 then
                    {throw-syntax-error
                        {hlmessage
                            This layout class definition includes vle-slot? = true
                            property bindings, which is not allowed.
                            Such property bindings are only allowed in
                            compound object definitions.
                        },
                        code
                    }
                }
                standard-members
            }
        }

    {return 
        {expand-template
            source-info = code,
            {define-class ?attributes
              ?fields
                
              ?generated-members

              ?other-members
            }
        }
    }
}

|| Purpose:
|| Parses a single layout-element in the external representation.
||
|| Comments:
||   code is the code to be parsed.
||   parse-index is the ParseIndex at which to start parsing the code.
||   container? is true if this layout element is a container.
||   visual-element? is true if this layout element is anything other
||      than {nonvisual-element ...}.
||   argument? is true if this layout element is {argument-container ...}.
||   format-version is the value associated with this layout class's
||      format-version meta-data binding.
|| This method side-effects the arrays "fields", "inits",
|| and "nonvisual-inits" by appending
|| to them.  Field definitions that result from parsing this layout
|| element are appended to "fields", and statements that should be
|| executed in the body of the initialize-components method are appended
|| to "inits" or "nonvisual-inits".  The statements in "nonvisual-inits"
|| are executed at the beginning of the initialize-components method,
|| before self.container or any of the other visual elements are created.
|| The statements in "inits" are executed after self.container is created.
|| If argument? is true, this method also returns the CurlSource for a
|| Curl expression that yields the value of the associated
|| {argument-container ...} element.
{define-proc {parse-layout-element 
                 code:CurlSource, 
                 index:ParseIndex, 
                 fields:{Array-of CurlSource}, 
                 nonvisual-inits:{Array-of CurlSource},
                 inits:{Array-of CurlSource},
                 slot-names:{Array-of VleSlotContentsInfo},
                 parent-slot-name:String,
                 container?:bool,
                 visual-element?:bool,
                 argument?:bool,
                 format-version:int
             }:#CurlSource
    let (expr:#Parsed, ni:ParseIndex) = {code.parse-expression index}
    let element-sb:SingleBinding = expr asa SingleBinding
    || Get the design name of this layout element.
    let name:Identifier = {non-null {element-sb.name.identifier}}
    let element-type:Parsed = {non-null element-sb.type}
    {if name.name != "void" then ||""
        || Create an identifier with the same name as this layout element's
        ||   design name, but distinct from that name, so that this identifier
        ||   is referenceable only from inside the expansion of this macro.
        ||   We don't need to do this if the design-name is void, since we
        ||   will never insert an identifier called "void" into the
        ||   macro-expanded output.
        set name = {Identifier name.name}
        {fields.append
            {expand-template 
                source-info = element-sb,
                field public ?element-sb = {uninitialized-value-for-type ?element-type}
            }
        }
    }
    let body:{Array-of Parsed} = {code.parse-parameters ni}
    let meta-data:CurlSource = {expand-template}
    let element-as-property-name:String = "" ||""
    let element-setter-method-name:String = "" ||""
    let vle-slot?:bool = false
    let vle-slot-name:String = ""
    let creator:#CurlSource = null
    {for e in body do
        {type-switch e
         case sb:SingleBinding do
            {assert visual-element?}
            {assert not argument?}
            let pname:String = {sb.name.identifier}.name
            {if pname == "set-element-as-property" then ||""
                set element-as-property-name = {sb.value.identifier}.name
             elseif pname == "set-element-using-method" then     ||""
                set element-setter-method-name = {sb.value.identifier}.name
             elseif pname == "vle-slot?" then     ||""
                let sname:String = name.name
                {if sname != "void" then          ||""
                    set vle-slot? = ({sb.value.literal} == true)
                    set vle-slot-name = sname
                }
             else
                set meta-data = {expand-template ?meta-data , ?sb}
            }
         else
            set creator = e
            {break}
        }
    }
    let arguments:{Array-of CurlSource} = 
        {new {Array-of CurlSource}}
    let arguments-empty?:bool = true
    let sub-inits:{Array-of CurlSource} = 
        {new {Array-of CurlSource}}
    let code:CurlSource = (creator asa Prefix).contents
    set (expr, ni) = {code.parse-expression BOS}
    let constructor-name:CurlSource = {non-null expr}

    {if vle-slot? then
        {slot-names.append
            {VleSlotContentsInfo
                vle-slot-name,
                {{constructor-name.get-text}.to-String}
            }
        }
    }

    let element?:bool
    let eat-comma?:bool
    {while true do
        set (expr, ni) = {code.parse-expression ni}
        {if ni == EOS then {break}}
        let e:CurlSource = {non-null expr}
        set element? = false
        set eat-comma? = true
        {type-switch e
         case pre:Prefix do
            let (match?:bool, body:CurlSource, pi:ParseIndex) =
                {has-prefix-name? pre, "layout-element"} ||""
            {if match? then
                {parse-layout-element
                    body, pi, fields, nonvisual-inits, sub-inits,
                    slot-names, vle-slot-name,
                    false, true, false, format-version
                }
                set element? = true
             else
                set (match?, body, pi) = 
                    {has-prefix-name? pre, "layout-container"} ||""
                {if match? then
                    {parse-layout-element
                        body, pi, fields, nonvisual-inits, sub-inits,
                        slot-names, vle-slot-name,
                        true, true, false, format-version
                    }
                    set element? = true
                 else
                    set (match?, body, pi) = 
                        {has-prefix-name? pre, "argument-container"} ||""
                    {if match? then
                        set e =
                            {non-null
                                {parse-layout-element
                                    body, pi, fields, nonvisual-inits, sub-inits,
                                    slot-names, vle-slot-name,
                                    true, true, true, format-version
                                }
                            }
                        set eat-comma? = false
                    }
                }
            }
        }
        {if not element? then
            {arguments.append
                {if arguments-empty? then
                    set arguments-empty? = false
                    e
                 else
                    {expand-template , ?e}
                }
            }
            {if eat-comma? then
                set (expr, ni) = {code.parse-token ni}||eat comma
            }
        }
    }
                    
    let add-defaults-proc:#CurlSource = null
    {if vle-slot? then
        set add-defaults-proc =
            {expand-template
                {proc {container:Visual}:void
                    let obj:Object =
                        {uninitialized-value-for-type Object}
                    ?sub-inits
                }
            }
    }

    {if vle-slot? then
        {assert container?}
        let run-time-type:String = {{constructor-name.get-text}.to-String}
        set creator =
            {expand-template 
                source-info = constructor-name,
                {value
                    let add-defaults-proc:{proc-type {Visual}:void} =
                        ?add-defaults-proc
                    let added-visual:#Visual = null
                    {if-non-null make-slot-proc then
                        let (av:#Visual, add-to-visual:Visual) =
                            {make-slot-proc
                                ?{Literal vle-slot-name},
                                ?{Literal run-time-type},
                                {Arguments ?arguments},
                                add-defaults-proc
                            }
                        {if-non-null av then
                            set added-visual = av
                            set ?={Identifier "self"}.vle-slot-containers-hash[?{Literal vle-slot-name}] = add-to-visual
                        }
                    }
                    {if-non-null added-visual then
                        || TODO: rhh 9/30/05 Think about the issues associated
                        ||   with not initializing slot-name fields when a
                        ||   compound object is loaded into the VLE:
                        added-visual
                     else
                        let container:?element-type = 
                            {?constructor-name ?arguments}
                        {add-defaults-proc container}
                        set ?={Identifier "self"}.?name = container
                        set ?={Identifier "self"}.vle-slot-containers-hash[?{Literal vle-slot-name}] = container
                        container
                    }
                }
            }
     || Note: must use ".size" below; using "empty?" causes curl2c to
     || fail.
     elseif sub-inits.size != 0 then
        {assert container?}
        set creator =
            {expand-template 
                source-info = constructor-name,
                {value
                    let container:?element-type = 
                        {?constructor-name ?arguments}
                    let obj:Object =
                        {uninitialized-value-for-type Object}
                    ?sub-inits
                    container
                }
            }
     else
        set creator = 
            {expand-template 
                source-info = constructor-name,
                {?constructor-name ?arguments}
            }
    }
    {if argument? then
        let result:CurlSource =
            {if name.name == "void" then ||""
                {non-null creator}
             else
                {expand-template
                    source-info = code,
                    {value
                        let ?name:?element-type = ?creator
                        set ?={Identifier "self"}.?name = ?name
                        ?name
                    }
                }
            }
        {return result}
     elseif visual-element? then
        let add-cmd:CurlSource =
            {if element-as-property-name != "" then ||""
                {expand-template
                    {set container.?{Identifier element-as-property-name} = obj}
                }
             elseif element-setter-method-name != "" then ||""
                {expand-template
                    {with-compiler-directives allow-implicit-any-casts? = true do
                        {container.?{Identifier element-setter-method-name}
                            (obj asa any)
                        }
                    }
                }
             else
                {expand-template {container.add obj ?meta-data}}
            }
        {if parent-slot-name != "" then
            set add-cmd =
                {expand-template
                    source-info = code,
                    {?={Identifier "self"}.vle-remember-default-slot-contents
                        ?={Literal parent-slot-name},
                        ?add-cmd
                    }
                }
        }
        {if format-version == 1 then
            set add-cmd =
                {expand-template
                    {do set obj.horigin = "left" ||""
                        set obj.vorigin = "bottom" ||""
                        ?add-cmd
                    }
                }
        }
        {if name.name == "void" or vle-slot? then ||""
            {inits.append 
                {expand-template
                    source-info = code,
                    set obj = ?creator
                    ?add-cmd
                }
            }
         else
            {inits.append 
                {expand-template
                    source-info = code,
                    let ?name:?element-type = ?creator
                    set obj = ?name
                    ?add-cmd
                    set ?={Identifier "self"}.?name = ?name
                }
            }
        }
     else
        || Come here if we're adding a nonvisual element.
        || (Nonvisual elements only exist where format-version > 1.)
        {if name.name == "void" then ||""
            {nonvisual-inits.append {non-null creator}}
         else
            {nonvisual-inits.append 
                {expand-template
                    source-info = code,
                    let ?name:?element-type = ?creator
                    set ?={Identifier "self"}.?name = ?name
                }
            }
        }
    }
    {return null}
}


|| Purpose:
|| Parse either a single class member (see parse-class-member) or
|| a SingleBinding.
{define-proc package {parse-class-member-or-single-binding
                         src:CurlSource,
                         start:ParseIndex
                     }:(#Parsed, ParseIndex)
    let (exp:#Parsed, next:ParseIndex) = {src.parse-expression start}
    {if exp isa SingleBinding then
        {return exp, next}
     else
        {return {parse-class-member src, start}}
    }
}


|| Purpose:
|| Macro generated by the VLE for defining the external representation of
|| new (VLE2) content. 
||
|| Comments:
|| This macro call expands into a define-class statement.  The class that
|| is defined will contain a field for each design name that has been
|| specified for an object in the VLE.  The class will also have a field
|| called "container" that holds a pointer to the top-level graphical
|| object in this layout.  The macro additionally creates a predefined
|| method called initialize-components that should be called from the
|| class constructor to create the graphical objects in the layout and
|| initialize the fields mentioned above.
{define-macro public {define-layout-class ?rest:tokens}
    {return {expand-template ?{parse-layout-class
                                  rest, BOS, format-version = 2
                              }}}
}


|| Purpose:
|| Macro generated by the VLE for defining the external representation of
|| a compound object.
||
|| Comments:
|| This macro call expands into a define-class statement.  The class that
|| is defined will contain a field for each design name that has been
|| specified for an object in the VLE.  The class will also have a field
|| called "container" that holds a pointer to the top-level graphical
|| object in this layout.  The macro additionally creates a predefined
|| method called initialize-components, similar to the
|| initialize-components method created by define-layout-class, and
|| creates a predefined method add-to-slot for adding an object to a
|| named slot of this compound object.
{define-macro public {define-compound-object ?rest:tokens}
    {return {expand-template ?{parse-layout-class
                                  rest, BOS,
                                  compound-object? = true,
                                  format-version = 2
                              }}}
}


|| Purpose:
|| Macro generated by the VLE for defining the external representation of
|| old (VLE1) content. 
{define-macro public {define-canvas-layout-class ?rest:tokens}
    {return {expand-template ?{parse-layout-class
                                  rest, BOS, format-version = 1
                              }}}
}

|| Purpose:
|| Content included in a source file that affects editor behavior
|| (by adding a panel to the editor's display) but is ignored at run time.
{define-macro public {define-editor-panel ?rest:tokens}
    {return {expand-template}}
}

|| Purpose:
|| Content included in a source file that affects editor behavior
|| (by evaluating specified code in the editor applet) but is ignored at run time.
{define-macro public {evaluate-in-editor ?rest:tokens}
    {return {expand-template}}
}


|| Purpose:
|| Class used with the define-canvas-layout-class macro.
||
|| Comments:
|| define-canvas-layout-class macro calls typically include an
|| {inherits ...} clause that inherits from LayoutEditorContainer.
|| This class is not used with define-layout-class or
|| define-compound-object.
{define-class public LayoutEditorContainer
  field public container:Box

  {constructor public {default container:Box}
    set self.container = container
  }
}


|| Purpose:
|| This macro is a no-op that can be inserted to prevent the VLE from generating
|| an import statement for a package that should not be imported in a file even
|| though an API in that package is being used in that file.
{define-macro public {already-imported ?rest:tokens}
    {return {expand-template}}
}


|| Purpose:
|| A RadioFrame that contains as its only child a Canvas.
|| 
|| Comments:
|| This is used to support radio buttons in the VLE.
{define-class public RadioCanvas {inherits RadioFrame}
  field private constant canvas:Canvas

  {constructor public {default
                          canvas:Canvas = {Canvas},
                          ...
                      }
    {construct-super ...}
    set self.canvas = canvas
    {self.add-internal self.canvas}
  }

  {api-version-switch
   case "4+" do
    {getter public {factor}:AntialiasFactor
        {return self.canvas.factor}
    }

    {setter public {factor factor:AntialiasFactor}
        set self.canvas.factor = factor
    }

    {getter public {use-host-rendering?}:bool
        {return self.canvas.use-host-rendering?}
    }

    {setter public {use-host-rendering? use-host-rendering?:bool}
        set self.canvas.use-host-rendering? = use-host-rendering?
    }
  }

  {method public {add g:any, ...}:#Visual
    {return {self.canvas.add g, ...}}
  }

  {method public {clear}:void
    {self.canvas.clear}
  }

  {method public {move-to-xy obj:any, x:any, y:any}:void
    {self.canvas.move-to-xy obj, x, y}
  }

  {method public {shift-xy obj:any, deltax:any, deltay:any}:void
    {self.canvas.shift-xy obj, deltax, deltay}
  }

  {method public {get-xy obj:any}:(x:Distance, y:Distance)
    let (x:Distance, y:Distance) = {self.canvas.get-xy obj}
    {return x, y}
  }

  {method public {set-anchor obj:any, new-anchor:CanvasAnchor}:void
    {self.canvas.set-anchor obj, new-anchor}
  }

  {method public {get-anchor obj:any}:CanvasAnchor
    {return {self.canvas.get-anchor obj}}
  }

  {getter public {graphical-children}:{Iterator-of Graphic}
    {return self.canvas.graphical-children}
  }

  {getter public {child-array}:{Array-of SequenceLayout}
    {return self.canvas.child-array}
  }
  
  {method public {find child:any}:int
    || Do some extra checking here to avoid bombing out in
    || self.canvas.find call in the case where child is the
    || child of a non-SequenceBox.
    {if child.parent == self.canvas then
        {return {self.canvas.find child}}
    }
    {return -1}
  }
}


|| Purpose:
|| A class that displays an image.
||
|| Comments:
|| This is necessary since the VLE can only instantiate classes, and there
|| is no class that represents an image in the GUI toolkit.
{define-class public ImageFrame {inherits BaseFrame}
  field private _source:#Url
  field private _blocking?:bool
  field private _ignore-exceptions?:bool

  {constructor public {default 
                          source:#Url = null,
                          blocking?:bool = false,
                          ignore-exceptions?:bool = true,
                          ...
                      }
    {construct-super ...}
    set self._source = source
    set self._blocking? = blocking?
    set self._ignore-exceptions? = ignore-exceptions?
    {self.recreate-image}
  }

  {getter public {source}:#Url
    {return self._source}
  }
  {setter public {source url:#Url}:void
    set self._source = url
    {self.recreate-image}
  }

  {getter public {blocking?}:bool
    {return self._blocking?}
  }
  {setter public {blocking? val:bool}:void
    set self._blocking? = val
    {self.recreate-image}
  }

  {getter public {ignore-exceptions?}:bool
    {return self._ignore-exceptions?}
  }
  {setter public {ignore-exceptions? val:bool}:void
    set self._ignore-exceptions? = val
    {self.recreate-image}
  }

  {method private {recreate-image}:void
    {if-non-null child = self.child then
        {child.detach}
    }
    {self.add-internal
        {image
            source = self.source,
            blocking? = self.blocking?,
            ignore-exceptions? = self.ignore-exceptions?
        }
    }
  }
}

{api-version-switch
 case "4+" do
    || Shapes support requires API version 4.0 or later.
    {let package constant placeholder-image-url:Url =
        {url "curl://install/curl-resources/default/images/placeholder.gif"}
    }

    || Utility procedure that's used to construct Shapes specified using
    || PixelDistances.
    {define-proc public {Distance2d-from-any x:any, y:any}:Distance2d
        {return {Distance2d {any-to-Distance x}, {any-to-Distance y}}}
    }

    || Utility procedure that's used to construct Shapes specified using
    || PixelDistances.
    {define-proc public {GRect-from-any
                            lextent:any,
                            rextent:any,
                            ascent:any,
                            descent:any
                        }:GRect
        {return
            {GRect
                {any-to-Distance lextent}, {any-to-Distance rextent},
                {any-to-Distance ascent}, {any-to-Distance descent}
            }
        }
    }

    || Purpose:
    || A class that displays an ImageShape.
    ||
    || Comments:
    || This is necessary since the curl ImageShape class doesn't have a url-based
    || API.
    {define-class public open VleImageShape {inherits ImageShape}
      field protected _url:#Url

      {constructor public {default
                              url:#Url = null,
                              ...
                          }
        set self.url = url
        {construct-super {self.create-pixmap-from-url}, ...}
      }

      {getter public open {url}:#Url
        {return self._url}
      }
      {setter public open {url url:#Url}:void
        set self._url = url
        set self.image = {self.create-pixmap-from-url}
      }

      {method protected open {create-pixmap-from-url}:Pixmap
        {if-non-null url = self._url then
            {try
                {return {Pixmap.from-url url}}
             catch e:Exception do
                || Fall through and use placeholder.
            }
        }
        {return {Pixmap.from-url placeholder-image-url}}
      }
    }
}


|| Purpose:
|| A synonym for Fill, used for the DesignTimeBorderFrame class.
||
|| Comments:
|| This object is used for displaying a border around a rectangular
|| region without actually containing (in the graphic hierarchy sense)
|| the items located inside the border.
{define-class public open BorderFrame {inherits Fill}

  {constructor public {default ...}
    {construct-super ...}
  }
}


|| Purpose:
|| Procedure for creating a graphical object by passing in creation
|| code.
||
|| Comments:
|| This is the runtime code generated by the UserDefinedGraphic palette item.
|| 
|| If no creation code is used, we just create a Fill.
{define-proc public {UserDefinedGraphic ...}:Graphic
    let obj-or-null:#Graphic = null
    {for (val, key) in ... do
        {if key == null then
            set obj-or-null = val asa Graphic
        }
    }

    || If no creation code was specified, provide default of {Fill}.
    let obj:Graphic =
        {if-non-null obj-or-null then
            obj-or-null
         else
            {Fill}
        }
    
    {for (val, key) in ... do
        {if-non-null key then
            {set-public-property obj, key, val}
        }
    }
    {return obj}
}


|| Purpose:
|| Alias for CommandButton, used for submit-buttons.
{let public constant SubmitCommandButton:Type = CommandButton}

|| Purpose:
|| Alias for CommandButton, used for reset-buttons.
{let public constant ResetCommandButton:Type = CommandButton}

{api-version-switch
 case "4+" do
    || TabContainer in CURL.GUI.CONTROLS, no import needed.
 else
    {import public TabContainer from CURL.GUI.EXTRAS}
}

{import public * from CURL.DATA-ACCESS.BASE}
{import public * from CURL.DATA-ACCESS.CONNECTED}

{define-proc public {make-connected-record-set
                        connection:Connection =
                            {uninitialized-value-for-type Connection},
                        database:String = "",
                        query:String = "",
                        request-modifiable?:bool = false,
                        size-limit:int = -1,
                        ...:EventHandler
                    }:ConnectedRecordSet
    {return
        {connection.create-record-set
            database,
            query,
            request-modifiable? = request-modifiable?,
            size-limit = size-limit,
            ...
        }
    }
}


|| Purpose:
|| TableContentPrototype that behaves like cell-prototype if there is
|| a child graphic, and like skip otherwise.
{define-proc public {vle-cell-prototype ...}:TableContentPrototype
    || First find out if there is a child graphic.
    let has-child?:bool = false
    let colspan:int = 1
    {for (val, k) in ... do
        {if k == null then
            set has-child? = true
            {break}
         elseif k == "colspan" then ||""
            set colspan = val
        }
    }
    || Then return the desired result.
    {if has-child? then
        {return {cell-prototype ...}}
     else
        {return {skip colspan}}
    }
}

{api-version-switch
 case "5+" do
    || Validation support requires API version 5.0 or later.

    || Support for MessageDisplay.  This support is required so that the
    || VLE doesn't have to worry about ordering layout element
    || initialization calls.  If support for re-ordering initialization is
    || added at some point, this code will no longer be necessary.

    {define-macro public {forward-display ?message-display:expression}
        {return
            {expand-template
                {ForwardingMessageDisplay
                    {proc {}:MessageDisplay {return ?message-display}}
                }
            }
        }
    }

    {define-class public ForwardingMessageDisplay {inherits MessageDisplay}
      field private constant md-thunk:{proc-type {}:MessageDisplay}
      field private md:#MessageDisplay

      {getter private {get-md}:MessageDisplay
        {return
            {if-non-null md = self.md then
                md
             else
                let md:MessageDisplay = {self.md-thunk}
                set self.md = md
                md
            }
        }
      }
      {constructor public {default md-thunk:{proc-type {}:MessageDisplay}}
        set self.md-thunk = md-thunk
      }

      {getter public {uses-dialog?}:bool
        {return self.get-md.uses-dialog?}
      }
      {method public {show
                         vc:ValidationComplete,
                         target:ActiveTraversor
                     }:void
        {self.get-md.show vc, target}
      }
      {method public {show-results results:ValidationResults}:void
        {self.get-md.show-results results}
      }
      {method public {clear}:void
        {self.get-md.clear}
      }
    }
}
